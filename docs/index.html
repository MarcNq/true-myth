<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>True Myth</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">True Myth</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> True Myth</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="true-myth">True Myth</h1>
				<p><a href="https://travis-ci.org/chriskrycho/true-myth"><img src="https://img.shields.io/travis/chriskrycho/true-myth/master.svg?style=flat-square" alt="Travis `master`"></a>
					<a href="https://www.npmjs.com/package/true-myth"><img src="https://img.shields.io/npm/v/true-myth.svg?style=flat-square" alt="npm"></a>
					<a href="https://github.com/chriskrycho/true-myth/releases"><img src="https://img.shields.io/github/tag/expressjs/express.svg?style=flat-square" alt="GitHub tag"></a>
					<img src="https://img.shields.io/badge/stability-experimental-purple.svg?style=flat-square&amp;colorB=b28cd9" alt="Stability">
					<a href="https://gitter.im/true-myth/Lobby"><img src="https://img.shields.io/gitter/room/nwjs/nw.js.svg?style=flat-square" alt="Gitter"></a>
					<a href="https://github.com/chriskrycho/true-myth/blob/master/LICENSE"><img src="https://img.shields.io/github/license/chriskrycho/true-myth.svg?style=flat-square" alt="license"></a>
					<a href="http://github.com/chriskrycho/true-myth/issues"><img src="https://img.shields.io/github/issues-raw/badges/shields.svg?style=flat-square" alt="Open GitHub Issues"></a>
				<a href="https://gratipay.com/true-myth/"><img src="https://img.shields.io/gratipay/project/true-myth.svg?style=flat-square" alt="Gratipay"></a></p>
				<p>A library for safe functional programming in JavaScript, with first-class
					support for TypeScript and Flow, that has <code>Maybe</code> and <code>Result</code> types, supporting both a
				functional style and a more traditional method-call style.</p>
				<ul>
					<li><a href="#just-the-api-please">Just the API, please</a><ul>
							<li><a href="#result-with-a-functional-style"><code>Result</code> with a functional style</a></li>
							<li><a href="#maybe-with-the-method-style"><code>Maybe</code> with the method style</a></li>
							<li><a href="#constructing-maybe">Constructing <code>Maybe</code></a></li>
							<li><a href="#safely-getting-at-values">Safely getting at values</a></li>
						</ul>
					</li>
					<li><a href="#what-is-this-for">What is this for?</a><ul>
							<li><a href="#the-problem">The problem</a></li>
							<li><a href="#the-solution">The solution</a></li>
						</ul>
					</li>
					<li><a href="#design-philosophy">Design philosophy</a><ul>
							<li><a href="#the-type-names">The type names</a><ul>
									<li><a href="#maybe"><code>Maybe</code></a><ul>
											<li><a href="#the-maybe-variants-some-and-nothing">The <code>Maybe</code> variants: <code>Some</code> and <code>Nothing</code></a></li>
										</ul>
									</li>
									<li><a href="#result"><code>Result</code></a><ul>
											<li><a href="#the-result-variants-ok-and-err">The <code>Result</code> variants: <code>Ok</code> and <code>Err</code></a></li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li><a href="#setup">Setup</a><ul>
							<li><a href="#javascript">JavaScript</a></li>
							<li><a href="#typescript">TypeScript</a></li>
							<li><a href="#flow">Flow</a></li>
						</ul>
					</li>
					<li><a href="#roadmap">Roadmap</a></li>
					<li><a href="#why-not">Why not...</a><ul>
							<li><a href="#folktale">Folktale</a></li>
							<li><a href="#sanctuary">Sanctuary</a></li>
						</ul>
					</li>
					<li><a href="#migrating-from-existing-libs">Migrating from existing libs</a></li>
					<li><a href="#whats-with-the-name">What&#39;s with the name?</a></li>
				</ul>
				<h2 id="just-the-api-please">Just the API, please</h2>
				<p><em>If you&#39;re unsure of why you would want to use the library, you might jump down
				to <a href="#what-is-this-for"><strong>What is this for?</strong></a>.</em></p>
				<p>These examples don&#39;t cover every corner of the API; it&#39;s just here to show you
					what a few of the functions are like. <a href="https://chriskrycho.github.io/true-myth/">Full API documentation is
				available!</a></p>
				<h3 id="-result-with-a-functional-style"><code>Result</code> with a functional style</h3>
				<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fallibleCheck</span>(<span class="hljs-params">isValid: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">Result</span>&lt;<span class="hljs-title">string</span>, </span>{ reason: <span class="hljs-built_in">string</span> }&gt; {
  <span class="hljs-keyword">return</span> isValid ? ok(<span class="hljs-string">'all fine here'</span>) : err({ reason: <span class="hljs-string">'was not valid'</span> });
}

<span class="hljs-keyword">const</span> describe = <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> <span class="hljs-string">'The outcome was: '</span> + s;

<span class="hljs-keyword">const</span> wentFine = fallibleCheck(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">const</span> mappedFine = map(describe, wentFine);
<span class="hljs-built_in">console</span>.log(toString(mappedFine)); <span class="hljs-comment">// "Ok(The outcome was: all fine here)"</span>

<span class="hljs-keyword">const</span> notGreat = fallibleCheck(<span class="hljs-literal">false</span>);
<span class="hljs-keyword">const</span> mappedBad = map(describe, notGreat);
<span class="hljs-built_in">console</span>.log(toString(mappedBad)); <span class="hljs-comment">// "Err({ reason: 'was not valid' })"</span>
</code></pre>
				<h3 id="-maybe-with-the-method-style"><code>Maybe</code> with the method style</h3>
				<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeLength</span>(<span class="hljs-params">mightBeAString: Maybe&lt;<span class="hljs-built_in">string</span>&gt;</span>): <span class="hljs-title">Maybe</span>&lt;<span class="hljs-title">number</span>&gt; </span>{
  <span class="hljs-keyword">return</span> mightBeAString.map(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.length);
}

<span class="hljs-keyword">const</span> someString = Maybe.some(<span class="hljs-string">'a string'</span>);
<span class="hljs-keyword">const</span> nothingHere = Maybe.nothing&lt;<span class="hljs-built_in">string</span>&gt;();
<span class="hljs-built_in">console</span>.log(safeLength(someString).toString()); <span class="hljs-comment">// "Some(8)"</span>
<span class="hljs-built_in">console</span>.log(safeLength(nothingHere).toString()); <span class="hljs-comment">// "Nothing"</span>
</code></pre>
				<h3 id="constructing-maybe-">Constructing <code>Maybe</code></h3>
				<p>You can use <code>Maybe.of</code> to construct a <code>Maybe</code> from any value. It will return a
				<code>Nothing</code> if the passed type is <code>null</code> or <code>undefined</code>, or a <code>Some</code> otherwise.</p>
				<pre><code class="lang-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">acceptsANullOhNo</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title">Maybe</span>&lt;<span class="hljs-title">string</span>&gt; </span>{
  <span class="hljs-keyword">const</span> maybeNumber = Maybe.of(value);
  <span class="hljs-keyword">return</span> mapOr(<span class="hljs-string">"0"</span>, <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n.toString(), maybeNumber);
}
</code></pre>
				<h3 id="safely-getting-at-values">Safely getting at values</h3>
				<p>Helpers are supplied to allow you to get at the values wrapped in the type:</p>
				<pre><code class="lang-ts"><span class="hljs-keyword">const</span> theAnswer = Result.ok(<span class="hljs-number">42</span>);
<span class="hljs-keyword">const</span> theAnwerValue = unsafelyUnwrap(theAnswer);
</code></pre>
				<p>However, as its name makes explicit <code>unsafelyUnwrap</code> is not a safe operation; if
					the item being unwrapped is an <code>Err</code>, this will throw an <code>Error</code>. Instead, you
				can use one of the safe unwrap methods:</p>
				<pre><code class="lang-ts"><span class="hljs-keyword">const</span> theAnswerValue = unwrapOr(<span class="hljs-number">0</span>, theAnswer);
</code></pre>
				<h2 id="what-is-this-for-">What is this for?</h2>
				<h3 id="the-history">The History</h3>
				<p>How do you represent the concept of not having anything, programmatically? As a
					language, JavaScript uses <code>null</code> to represent this concept; if you have a
					variable <code>myNumber</code> to store numbers, you might assign the value <code>null</code> when you
					don&#39;t have any number at all. If you have a variable <code>myString</code>, you might set
				<code>myString = null;</code> when you don&#39;t have a string.</p>
				<p>Some JavaScript programmers use <code>undefined</code> in place of <code>null</code> or in addition to
					<code>null</code>, so rather than setting a value to <code>null</code> they might just set <code>let
myString;</code> or even <code>let myString = undefined;</code>.</p>
				<h3 id="the-problem">The problem</h3>
				<p>Every language needs a way to express the concept of nothing, but <code>null</code> and
					<code>undefined</code> are a curse. Their presence in JavaScript (and in many other
					languages) introduce a host of problems, because they are not a particularly
					<em>safe</em> way to represent the concept. Say, for a moment, that you have a function
				that takes an integer as a parameter:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">let</span> myNumber = <span class="hljs-literal">undefined</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFuncThatTakesAnInteger</span>(<span class="hljs-params">anInteger</span>) </span>{
  <span class="hljs-keyword">return</span> anInteger.toString();
}

myFuncThatTakesAnInteger(myNumber); <span class="hljs-comment">// TypeError: anInteger is undefined</span>
</code></pre>
				<p><img src="https://user-images.githubusercontent.com/2403023/31154374-ac25ce0e-a874-11e7-9399-73ad99d9d6cb.png" alt="this is fine"></p>
				<p>When the function tries to convert the integer to a string, the function blows
					up because it was written with the assumption that the parameter being passed in
					(a) is defined and (b) has a <code>toString</code> method. Neither of these assumptions are
					true when <code>anInteger</code> is <code>null</code> or <code>undefined</code>. This leads JavaScript
					programmers to program defensively, with <code>if (!anInteger) return;</code> style guard
					blocks at the top of their functions. This leads to harder-to-read code, and
					what&#39;s more, <em>it doesn&#39;t actually solve the root problem.</em> You could imagine
					this situation playing itself out in a million different ways: arguments to
					functions go missing. Values on objects turn out not to exist. Arrays are absent
				instead of merely empty.</p>
				<p>The result is a steady stream not merely of programming frustrations, but of
					<em>errors</em>. The program does not function as the programmer intends. That means
					stuff doesn&#39;t work correctly for the user of the software. Imagine a hammer
					where the head just slips off every so often, in ways you could compensate for
				but which makes it that much harder to just get the nail into the wood.</p>
				<p>That&#39;s what <code>null</code> and <code>undefined</code> are. You can program around them. But
				defensive programming is gross. You write a lot of things like this:</p>
				<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNil</span>(<span class="hljs-params">thingToCheck</span>) </span>{
  <span class="hljs-keyword">return</span> thingToCheck === <span class="hljs-literal">undefined</span> || thingToCheck === <span class="hljs-literal">null</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAThing</span>(<span class="hljs-params">withAString</span>) </span>{
  <span class="hljs-keyword">if</span> (isNil(withAString)) {
    withAString = <span class="hljs-string">'some default value'</span>;
  }

  <span class="hljs-built_in">console</span>.log(withAString.length);
}
</code></pre>
				<p>If you forget that check, or simply assume, &quot;Look, I&#39;ll <em>never</em> call this
					without including the argument,&quot; eventually you or someone else will get it
					wrong. Usually somewhere far away from the actual invocation of <code>doAThing</code>, so
				that it&#39;s not obvious why that value ended up being <code>null</code> there.</p>
				<p>TypeScript and Flow take us a big step in that direction, so long as our type
					annotations are good enough. (Use of <code>any</code> will leave us sad, though.) We can
					specify that type <em>may</em> be present, using the <a href="https://flow.org/en/docs/types/maybe/">maybe</a>/<a href="http://www.typescriptlang.org/docs/handbook/interfaces.html#optional-properties">optional</a> annotation.
					This at least helps keep us honest. But we still end up writing a ton of
					repeated boilerplate to deal with this problem. Rather than just handling it
					once and being done with it, we play a never-ending game of whack-a-mole. We
					must be constantly vigilant and proactive so that our users don&#39;t get into
				broken error states. Are you tired of the game yet?</p>
				<h3 id="the-solution">The solution</h3>
				<p><code>Maybe</code> and <code>Result</code> are our escape hatch from all this madness. </p>
				<p>We reach for libraries precisely so we can solve real business problems
					while letting lower-level concerns live in the &quot;solved problems&quot; category. True
					Myth, borrowing ideas from many other languages and libraries, aims to put
					<em>code written to defend against <code>null</code>/<code>undefined</code> problems</em> in that &quot;solved
				problems&quot; category.</p>
				<p><code>Maybe</code> and <code>Result</code> solve this problem <em>once</em>, and <em>in a principled way</em>,
					instead of in an <em>ad-hoc</em> way throughout your codebase, by putting the value
					into a <em>container</em> which is guaranteed to be safe to act upon, regardless of
				whether there&#39;s something inside it or not.</p>
				<p>These containers let us write functions with <em>actually safe</em> assumptions about
					parameter values by extracting the question, &quot;Does this variable contain a valid
					value?&quot; to API boundaries, rather than needing to ask that question at the head
				of every. single. function.</p>
				<p>What is this sorcery?</p>
				<p>It turns out you probably already have a good idea of how this works, if you&#39;ve
				spent much time writing JavaScript, because this is exactly how arrays work.</p>
				<p>Imagine, for a moment, that you have a variable <code>myArray</code> and you want to map
					over it and print out every value to the console. You instantiate it as an empty
				array and then forget to load it up with values before mapping over it:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">let</span> myArray = [];

<span class="hljs-comment">// oops, I meant to load up the variable with an array, but I forgot!</span>

myArray.forEach(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(n)); <span class="hljs-comment">// &lt;nothing prints to the screen&gt;</span>
</code></pre>
				<p>Even though this doesn&#39;t print anything to the screen, it doesn&#39;t unexpectedly
					blow up, either. In other words, it represents the concept of having nothing
					&quot;inside the box&quot; in a safe manner. By contrast, an integer has no such safe box
					around it. What if you could multiply an integer by two, and if your variable
				was &quot;empty&quot; for one reason or another, it wouldn&#39;t blow up?</p>
				<pre><code class="lang-js"><span class="hljs-keyword">let</span> myInteger = <span class="hljs-literal">undefined</span>;

myInteger * <span class="hljs-number">3</span>; <span class="hljs-comment">// :(</span>
</code></pre>
				<p>Let&#39;s try that again, but this time let&#39;s put the actual value in a container
				and give ourselves safe access methods:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">let</span> myInteger = Maybe.of(<span class="hljs-literal">undefined</span>);

myInteger.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">3</span>); <span class="hljs-comment">// Nothing</span>
</code></pre>
				<p><img src="https://user-images.githubusercontent.com/2403023/31098390-5d6573d0-a790-11e7-96f9-361d2e70522b.gif" alt="mind blown"></p>
				<p>We received <code>Nothing</code> back as our value, which isn&#39;t particularly useful, but it
				also didn&#39;t halt our program in its tracks!</p>
				<p><code>Result</code> is similar to <code>Maybe</code>, except it packages up the result of an operation
					(like a network request) whether it&#39;s a success (an <code>Ok</code>) or a failure (an
					<code>Err</code>) and lets us unwrap the package at our leisure. Whether you get back a 200
					or a 401 for your HTTP request, you can pass the box around the same either way;
					the methods and properties the container has are not dependent upon whether
				there is shiny new data or a big red error inside.</p>
				<ul>
					<li>[ ] TODO: comments on type safety via TS and Flow</li>
				</ul>
				<h2 id="design-philosophy">Design philosophy</h2>
				<p>The design aims for True Myth are:</p>
				<ul>
					<li>to be as idiomatic as possible in JavaScript</li>
					<li>to support a natural functional programming style</li>
					<li>to have zero runtime cost beyond simple object construction and function
					invocation</li>
					<li>to lean heavily on TypeScript and Flow to enable all of the above</li>
				</ul>
				<p>In practice, that means:</p>
				<ul>
					<li><p>You can construct the variant types in the traditional JavaScript way or
						with a pure function:</p>
						<pre><code class="lang-ts">const classicalSome = new Some(&#39;value&#39;);
const functionalSome = some(&#39;value&#39;);
const classicalNothing = new Nothing();
const functionalNothing = nothing();
</code></pre>
					</li>
					<li><p>Similarly, you can use methods or pure functions:</p>
						<pre><code class="lang-ts"><span class="hljs-keyword">const</span> numberResult = ok(<span class="hljs-number">42</span>);
<span class="hljs-keyword">const</span> ok84 = numberResult.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> ok21 = map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x / <span class="hljs-number">2</span>, numberResult);
</code></pre>
						<p>As this second example suggests, the aim has been to support the most
							idiomatic approach for each style. This means that yes, you might find it a
							bit confusing if you&#39;re actively switching between the two of them. (Why
						would you do that?!?)</p>
					</li>
					<li><p>Using the library with TypeScript or Flow will <em>just work</em> and will provide
							you with considerable safety out of the box. Using it with JavaScript will
							work just fine, but there is no runtime checking, and you&#39;re responsible to
							make sure you don&#39;t <code>unwrap()</code> a <code>Maybe</code> without checking that it&#39;s safe to
						do so.</p>
					</li>
					<li><p>Since this is a TypeScript- and Flow-first library, we intentionally leave
							out any runtime type checking. As such, you <em>should</em> make use of the type
							systems if you want the benefits of the system. Many of the functions simply
							assume that the types are checked, and <em>will</em> error if you pass in items of
						the wrong type.</p>
						<p>For example, if you pass a non-<code>Maybe</code> instance to many functions, they will
							simply fail – even the basic helpers like <code>isSome</code> and <code>isNothing</code>. These
							assumptions have been made precisely <em>because</em> this is a TypeScript- and
							Flow-first library. (See the discussion below comparing True Myth to
							Folktale and Sanctuary if you aren&#39;t using TypeScript or Flow and need
						runtime checking.)</p>
					</li>
				</ul>
				<p>The overarching themes are flexibility and approachability.</p>
				<p>The hope is that a team just picking up these ideas for the first time can use
					them without adapting their whole style to a &quot;traditional&quot; functional
					programming approach, but a team comfortable with functional idioms will find
					themselves at home with the style of data-last pure functions. (For a brief
					discussion of why you want the data last in a functional style, see <a href="http://www.chriskrycho.com/2017/collection-last-auto-curried-functions.html">this blog
				post</a>.)</p>
				<p>(As a closely related note: True Myth does not currently supply curried variants
					of the functions. There are a <em>lot</em> of good options out there for that; both
					<a href="https://lodash.com">lodash</a> and <a href="http://ramdajs.com">Ramda</a> have tools for currying existing function definitions. It
					also profoundly complicates writing the type signatures for these functions,
					since neither TypeScript nor Flow can easily represent auto- curried functions –
					unsurprisingly, given they&#39;re uncommon in JavaScript. Using Ramda or lodash to
					get curried versions of the functions may be a huge win for you in your
				codebase, though!)</p>
				<h3 id="the-type-names">The type names</h3>
				<h4 id="-maybe-"><code>Maybe</code></h4>
				<p>The existing options in this space include <code>Option</code>, <code>Optional</code>, and <code>Maybe</code>.
					You could also point to &quot;nullable,&quot; but that actually means the <em>opposite</em> of
				what we&#39;re doing here – these represent types which can <em>not</em> be nullable!</p>
				<p><code>Option</code> implies a choice between several different <em>options</em>; in this case
					that&#39;s not really what&#39;s going on. It&#39;s also not really a great word for the
					type in the sense that it&#39;s weird to read aloud: &quot;an Option string&quot; doesn&#39;t make
				any sense in English.</p>
				<p><code>Optional</code> is much better than <code>Option</code>. The semantics are much more accurate,
					in that it captures that the thing is allowed to be absent. It&#39;s also the nicest
				grammatically: &quot;an Optional string&quot;. On the other hand, it&#39;s also the <em>longest</em>.</p>
				<p><code>Maybe</code> seems to be the best type name semantically: we&#39;re modeling something
					which <em>may</em> be there – or may <em>not</em> be there! Grammatically, it&#39;s comparable to
					&quot;optional&quot;: &quot;a Maybe string&quot; isn&#39;t great – but &quot;maybe a string&quot; is the most
					natural <em>accurate</em> way to answer the question, &quot;What&#39;s in this field?&quot; It&#39;s also
				the shortest!</p>
				<p><code>Optional</code> or <code>Maybe</code> are both good names; <code>Maybe</code> just seemed slightly better.</p>
				<h5 id="the-maybe-variants-some-and-nothing-">The <code>Maybe</code> variants: <code>Some</code> and <code>Nothing</code></h5>
				<p>Similar consideration was given to the names of the type variants. Options for
					the &quot;present&quot; type in other libraries are <code>Some</code> and <code>Just</code>. Options for the
				&quot;absent&quot; type are <code>None</code> or <code>Nothing</code>.</p>
				<ul>
					<li>[ ] TODO: elaborate on reasons for <code>Some</code> and <code>Nothing</code></li>
				</ul>
				<h4 id="-result-"><code>Result</code></h4>
				<ul>
					<li>[ ] TODO: Explain why <code>Result</code></li>
				</ul>
				<h5 id="the-result-variants-ok-and-err-">The <code>Result</code> variants: <code>Ok</code> and <code>Err</code></h5>
				<ul>
					<li>[ ] TODO: explain why <code>Ok</code> and <code>Err</code> (esp. instead of <code>Error</code>)</li>
				</ul>
				<h2 id="setup">Setup</h2>
				<h3 id="javascript">JavaScript</h3>
				<ul>
					<li>[ ] TODO: JS setup</li>
				</ul>
				<h3 id="typescript">TypeScript</h3>
				<ul>
					<li>[ ] TODO: TS setup</li>
				</ul>
				<h3 id="flow">Flow</h3>
				<ul>
					<li>[ ] TODO: Flow setup</li>
				</ul>
				<h2 id="roadmap">Roadmap</h2>
				<p>Before this hits 1.0, I will do:</p>
				<ul>
					<li><p>[x] <code>Maybe</code></p>
						<ul>
							<li>[x] add aliases for the standard names, e.g. <code>bind</code>, <code>chain</code>, etc.</li>
							<li>[x] finish documentation</li>
						</ul>
					</li>
					<li><p>[ ] <code>Result</code></p>
						<ul>
							<li>[x] implement</li>
							<li>[ ] document</li>
						</ul>
					</li>
					<li><p>[x] <em>All</em> the exports</p>
						<ul>
							<li>[x] AMD</li>
							<li>[x] ES modules</li>
							<li>[x] CommonJS modules</li>
						</ul>
					</li>
					<li><p>[ ] Ember CLI integration</p>
					</li>
				</ul>
				<p>If you think another type should be in this list, please <a href="https://github.com/chriskrycho/true-myth/issues">open an issue</a>!</p>
				<h2 id="why-not-">Why not...</h2>
				<p>There are other great functional programming libraries out there... so why not
				just use one of them?</p>
				<h3 id="folktale-">Folktale?</h3>
				<p>Folktale has an API a lot like this one, as you&#39;ll see when perusing the docs.
				However, there are two main reasons you might prefer True Myth to Folktale:</p>
				<ol>
					<li><p>True Myth is TypeScript-first and Flow-first, which means that it assumes
						you are using TypeScript or Flow if you&#39;re aiming for rigorous type safety.</p>
						<p>By contrast, Folktale is a JavaScript-first library, with runtime checking
							built in for its types. Folktale&#39;s TypeScript support is in-progress, but
							will remain secondary until a TypeScript rewrite of the whole Folktale
						library lands... eventually.</p>
						<p>There&#39;s value in both of these approaches, so True Myth aims to take
						advantage of the compilers and play in a no-runtime-cost space.</p>
						<p>If you want a JS-focused (rather than TS- or Flow-focused) library which
							will help you be safer without a compiler, you should definitely pick
							Folktale over True Myth. If you&#39;ve already using TS or Flow, True Myth is a
						bit nicer of an experience.</p>
					</li>
					<li><p>True Myth aims to keep functional programming jargon to a minimum and to use
							TypeScript and Flow type notation throughout its docs as well as in its
						implementation.</p>
						<p>Folktale is aimed squarely at people who are already pretty comfortable with
							the world of strongly-typed functional programming languagues. This is
							particularly evident in the way its type signatures are written out (using
							the same basic notation you might see in e.g. Haskell), but it&#39;s also there
						in its heavy use of functional programming terminology throughout its docs.</p>
						<p>Haskell-style types are quite nice, and functional programming jargon is
							very useful. However, they&#39;re also another hump to get over. Again: a
						tradeoff.</p>
						<p>By opting for type notation that TS or Flow developers are already familiar
							with, and by focusing on what various functions <em>do</em> rather than the usual
							FP names for them, True Myth aims at people just coming up to speed on
						these ideas.</p>
						<p>The big win for Folktale over True Myth is <a href="https://github.com/fantasyland/fantasy-land">Fantasy Land</a> compatibility.</p>
					</li>
				</ol>
				<ol>
					<li><p>True Myth&#39;s API aims to be more idiomatic as JavaScript/TypeScript, with a
						couple differences in particular worth calling out:</p>
						<ul>
							<li><p><strong>function naming convention:</strong> True Myth uses PascalCase for types and
									camelCase for functions – so, <code>new Some(5)</code> and <code>some(5)</code>, whereas
									FolkTale uses the capitals as function names for type constructors, i.e.
								<code>Some(5)</code>, and does not support <code>new</code>.</p>
							</li>
							<li><p><strong>ease of construction from nullable types:</strong> True Myth allows you to
									construct <code>Maybe</code> types from nullable types with <code>Maybe.of</code>, because JS
									is <em>full</em> of <code>null</code> and <code>undefined</code>, and allowing <code>Maybe.of</code> to handle
								them makes it easier to be sure you&#39;re always doing the right thing.</p>
								<p>Folktale&#39;s <code>Maybe.of</code> only allows the use of non-nullable types, and
									requires you to use <code>Maybe.fromNullable</code> instead. This isn&#39;t
									unreasonable, but it dramatically decreases the convenience of
									integration with existing JS codebases or interfacing with untyped JS
								libraries.</p>
							</li>
						</ul>
					</li>
				</ol>
				<h3 id="sanctuary-">Sanctuary?</h3>
				<ul>
					<li>[ ] TODO: kind of the same as Folktale, but add specific details</li>
				</ul>
				<h2 id="migrating-from-other-libraries">Migrating from other libraries</h2>
				<ul>
					<li>[ ] TODO: instructions for migrating from Folktale 1.0/2.0</li>
					<li>[ ] TODO: instructions for migrating from Sanctuary</li>
				</ul>
				<h2 id="what-s-with-the-name-">What&#39;s with the name?</h2>
				<ul>
					<li>[ ] TODO: Tolkien/Lewis, also Folktale/FantasyLand/Sanctuary. Nice resonance</li>
				</ul>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_index_.html">"index"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_maybe_.html">"maybe"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_result_.html">"result"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_utils_.html">"utils"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>